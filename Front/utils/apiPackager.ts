
import JSZip from 'jszip';
import { saveAs } from 'file-saver';

interface ApiPackageData {
  name: string;
  code: string;
  language: string;
  description?: string;
  function_type?: string; // 'standard' | 'database_query'
}

export const generateAndDownloadApiPackage = async (data: ApiPackageData) => {
  const zip = new JSZip();
  const folderName = data.name.toLowerCase().replace(/[^a-z0-9-_]/g, '');
  const root = zip.folder(folderName);

  if (!root) throw new Error("Failed to create zip folder");

  // 1. main.py - The user's actual code
  // Ensure we import necessary libs if it's a database query but they aren't explicit
  let mainCode = data.code;
  if (data.function_type === 'database_query' && !mainCode.includes('import sqlalchemy')) {
      mainCode = `import sqlalchemy\nfrom sqlalchemy import create_engine, text\n\n${mainCode}`;
  }
  root.file("main.py", mainCode);

  // 2. server.py - A Flask wrapper to make it runnable immediately
  const serverCode = `
import os
import logging
from flask import Flask, request, jsonify
from main import main

# Configure Logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

app = Flask(__name__)

@app.route('/health', methods=['GET'])
def health():
    return jsonify({"status": "ok", "service": "${data.name}"})

@app.route('/execute', methods=['POST'])
def execute():
    try:
        # Extract JSON body
        params = request.json or {}
        
        # Log execution
        logger.info(f"Executing function with params keys: {list(params.keys())}")
        
        # Run the user function
        result = main(**params)
        
        return jsonify(result)
    except Exception as e:
        logger.error(f"Execution Error: {str(e)}")
        return jsonify({"error": str(e), "status": "failed"}), 400

if __name__ == '__main__':
    port = int(os.environ.get("PORT", 8000))
    print(f"ðŸš€ Starting ${data.name} API on port {port}...")
    app.run(host='0.0.0.0', port=port)
`;
  root.file("server.py", serverCode);

  // 3. requirements.txt
  const baseReqs = [
    "flask==3.0.0",
    "gunicorn==21.2.0",
    "requests==2.31.0",
    "python-dotenv==1.0.0"
  ];
  
  if (data.function_type === 'database_query' || data.code.includes('sqlalchemy')) {
      baseReqs.push("sqlalchemy==2.0.23");
      baseReqs.push("psycopg2-binary==2.9.9"); // Default to Postgres adapter
      baseReqs.push("mysql-connector-python==8.2.0"); 
  }

  if (data.code.includes('pandas')) baseReqs.push("pandas==2.1.3");
  if (data.code.includes('numpy')) baseReqs.push("numpy==1.26.2");
  
  root.file("requirements.txt", baseReqs.join("\n"));

  // 4. Dockerfile
  const dockerfile = `
# Use official lightweight Python image
FROM python:3.10-slim

# Set working directory
WORKDIR /app

# Install system dependencies (needed for some DB drivers)
RUN apt-get update && apt-get install -y --no-install-recommends \\
    gcc \\
    libpq-dev \\
    && rm -rf /var/lib/apt/lists/*

# Copy requirements and install
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copy application code
COPY . .

# Expose port
EXPOSE 8000

# Run with Gunicorn for production performance
CMD ["gunicorn", "--bind", "0.0.0.0:8000", "server:app"]
`;
  root.file("Dockerfile", dockerfile);

  // 5. README.md
  const readme = `
# ${data.name} API

Generated by CodeGenie. This is a standalone microservice containing your logic.

## Logic Description
${data.description || "No description provided."}

## Local Setup

1. **Install Dependencies**
   \`\`\`bash
   pip install -r requirements.txt
   \`\`\`

2. **Run Server**
   \`\`\`bash
   python server.py
   \`\`\`
   The API will be available at \`http://localhost:8000/execute\`.

3. **Test**
   \`\`\`bash
   curl -X POST http://localhost:8000/execute -H "Content-Type: application/json" -d '{}'
   \`\`\`

## Docker Deployment

1. **Build Image**
   \`\`\`bash
   docker build -t ${folderName}:latest .
   \`\`\`

2. **Run Container**
   \`\`\`bash
   docker run -p 8000:8000 ${folderName}:latest
   \`\`\`
`;
  root.file("README.md", readme);

  // 6. Generate Blob
  const content = await zip.generateAsync({ type: "blob" });
  saveAs(content, `${folderName}_v1.0.zip`);
};
